# -*- coding: utf-8 -*-
"""MARKOV_CHAINS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10430RXZ9OgfMoH14Kh2DaNcXar2h0T5k

## MARKOV CHAINS
"""

import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import math

# type(historical_stock_data) is a data frame as data is dataframe

from google.colab import drive
drive.mount('/content/drive')
import sys

sys.path.append('/content/drive/MyDrive/MY_ONLINE_DATA_NEEDED_FILES/MY_LIBRARY_FOR_OPTIONS_TRADING/')
import my_library_17 as my_lib

def cal_markov_chains(symbol):
  data=yf.download(tickers=f'{symbol}.NS',period='max',interval='1d')
  historical_stock_data=data[['Adj Close']]
  historical_stock_data['pct_chnage']=historical_stock_data['Adj Close'].pct_change().dropna()
  mean=historical_stock_data['pct_chnage'].mean()
  std=historical_stock_data['pct_chnage'].std()


  q25 = np.percentile(historical_stock_data['pct_chnage'].dropna(), 25)
  q50 = np.percentile(historical_stock_data['pct_chnage'].dropna(), 50)
  q75 = np.percentile(historical_stock_data['pct_chnage'].dropna(), 75)

  # Initialize counters
  ll = ml = hl = lm = mm = hm = hh = lh = mh = 0

  # Iterate through the data to count transitions
  for i in range(1, len(historical_stock_data)):
      prev_change = historical_stock_data.iloc[i-1, 1]
      curr_change = historical_stock_data.iloc[i, 1]

      if prev_change < q25 and curr_change < q25:
          ll += 1
      if q25 <= prev_change <= q75 and curr_change < q25:
          ml += 1
      if prev_change > q75 and curr_change < q25:
          hl += 1
      if prev_change < q25 and q25 <= curr_change <= q75:
          lm += 1
      if q25 <= prev_change <= q75 and q25 <= curr_change <= q75:
          mm += 1
      if prev_change > q75 and q25 <= curr_change <= q75:
          hm += 1
      if prev_change > q75 and curr_change > q75:
          hh += 1
      if prev_change < q25 and curr_change > q75:
          lh += 1
      if q25 <= prev_change <= q75 and curr_change > q75:
          mh += 1

  # Compute the transition matrix
  transition_matrix_for_markov_chains = np.array([
      [ll / (ll + lm + lh), lm / (ll + lm + lh), lh / (ll + lm + lh)],
      [ml / (ml + mm + mh), mm / (ml + mm + mh), mh / (ml + mm + mh)],
      [hl / (hl + hm + hh), hm / (hl + hm + hh), hh / (hl + hm + hh)]
  ])
  print("Transition Matrix:")
  print(transition_matrix_for_markov_chains)

  return mean,std,q25,q50,q75,transition_matrix_for_markov_chains

def get_price_path_based_on_markov_chain(access_token_value,instrument_key,symbol,n_simulations):
  # Historical data properties
  mean,std,q25,q50,q75,transition_matrix_for_markov_chains=cal_markov_chains(symbol)

  mean_return = mean  # Mean daily return (0.05%)
  std_dev = std # Standard deviation of daily returns (1%)

  # Define transition matrix (example)
  P = transition_matrix_for_markov_chains

  # Define the states and initial state
  states = ['D1', 'S', 'I1']
  initial_state = 'S'#?
  initial_price = my_lib.get_last_traded_price(access_token_value,instrument_key,symbol)

  # Map states to index
  state_index = {'D1': 0, 'S': 1, 'I1': 2}
  # Run simulation 1000 times
  n_simulations = n_simulations
  n_days=my_lib.weekdays_until_last_thursday()
  all_price_paths = np.array([simulate_price_path(n_days,initial_state,initial_price,P,state_index,states,std_dev,q25,q50,q75) for _ in range(n_simulations)])

  # Calculate statistics
  mean_prices = np.mean(all_price_paths)

  print("Mean Prices:")
  print(mean_prices)

  print("5th percentile:")
  print(np.percentile(all_price_paths, 5))
  print("95th percentile:")
  print(np.percentile(all_price_paths, 95))

# Define function to get next state
def get_next_state(current_state,P,state_index,states):
    return np.random.choice(states, p=P[state_index[current_state]])

# Define function to get price change based on state
def get_price_change(state,std_dev,q25,q50,q75):
    if state == 'D1':
        return np.random.normal(q25, std_dev)  # Decrease
    elif state == 'S':
        return np.random.normal(q50, std_dev)  # Neutral
    elif state == 'I1':
        return np.random.normal(q75, std_dev)  # Increase

# Define function to simulate price path
def simulate_price_path(n_days,initial_state,initial_price,P,state_index,states,std_dev,q25,q50,q75):
    current_state = initial_state
    current_price = initial_price
    price_path = [current_price]

    for _ in range(n_days):
        next_state = get_next_state(current_state,P,state_index,states)
        price_change = get_price_change(next_state,std_dev,q25,q50,q75)
        current_price *= (1 + price_change)
        price_path.append(current_price)
        current_state = next_state

    return price_path[-1]