{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ef973f0c",
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"MY_LIBRARY.ipynb\n",
    "\n",
    "Automatically generated by Colab.\n",
    "\n",
    "Original file is located at\n",
    "    https://colab.research.google.com/drive/10hVGu2_6lE-AWMTQG6uz8m8XH5sEfg4b\n",
    "\n",
    "##  GET_ACCESS_TOKEN\n",
    "\"\"\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d909f897",
   "metadata": {
    "lines_to_next_cell": 1
   },
   "outputs": [],
   "source": [
    "import requests\n",
    "import pandas as pd\n",
    "def  get_access_token(code,apikey,secretkey):\n",
    "  url = 'https://api.upstox.com/v2/login/authorization/token'\n",
    "  headers = {\n",
    "      'accept': 'application/json',\n",
    "      'Content-Type': 'application/x-www-form-urlencoded',\n",
    "  }\n",
    "\n",
    "  data = {\n",
    "      'code': code,\n",
    "      'client_id': apikey,\n",
    "      'client_secret': secretkey,\n",
    "      'redirect_uri': 'https://127.0.0.1:5000/',\n",
    "      'grant_type': 'authorization_code',\n",
    "  }\n",
    "\n",
    "  response = requests.post(url, headers=headers, data=data)\n",
    "\n",
    "  # Check the response status\n",
    "  if response.status_code == 200:\n",
    "      # Parse the JSON response\n",
    "      data = response.json()\n",
    "\n",
    "      # Convert to DataFrame\n",
    "      df_token = pd.DataFrame(data.items(), columns=['Key', 'Value'])\n",
    "\n",
    "      # Print the DataFrame\n",
    "      print(df_token)\n",
    "\n",
    "  else:\n",
    "      # Print an error message if the request was not successful\n",
    "      print(f\"Error: {response.status_code} - {response.text}\")\n",
    "\n",
    "  # Alternatively, you can use loc\n",
    "  access_token_value = df_token.loc[df_token['Key'] == 'access_token', 'Value'].iloc[0]\n",
    "\n",
    "  # Print the access_token value\n",
    "  # print(\"Access Token:\", access_token_value)\n",
    "  return access_token_value"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "565e754e",
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"## GET LTP\"\"\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e45f2d8e",
   "metadata": {
    "lines_to_next_cell": 1
   },
   "outputs": [],
   "source": [
    "import requests\n",
    "import json"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "45a82552",
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_last_traded_price(access_token_value,instrument_key,symbol):\n",
    "    ltp=-1\n",
    "    url = f'https://api.upstox.com/v2/market-quote/ltp?instrument_key={instrument_key}'\n",
    "    headers = {\n",
    "        'Accept': 'application/json',\n",
    "        'Authorization': f'Bearer {access_token_value}'\n",
    "    }\n",
    "\n",
    "\n",
    "    # Make the HTTP GET request\n",
    "    response = requests.get(url, headers=headers)\n",
    "\n",
    "    # Check if the request was successful (status code 200)\n",
    "    if response.status_code == 200:\n",
    "        # Parse the JSON response\n",
    "        response_data = response.json()\n",
    "\n",
    "\n",
    "        for key in response_data['data']:\n",
    "          ltp = response_data['data'][key]['last_price']\n",
    "\n",
    "\n",
    "        # Return the LTP\n",
    "\n",
    "        return ltp\n",
    "    else:\n",
    "        # Print an error message if the request was not successful\n",
    "        print(f\"Failed to fetch data. Status code: {response.status_code}\")\n",
    "        return None"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e6960d81",
   "metadata": {
    "lines_to_next_cell": 1
   },
   "outputs": [],
   "source": [
    "from datetime import datetime, timedelta"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fc8c21f6",
   "metadata": {
    "lines_to_next_cell": 1
   },
   "outputs": [],
   "source": [
    "def weekdays_until_last_thursday():\n",
    "    # Get the current date\n",
    "    today = datetime.today()\n",
    "\n",
    "    # Get the first day of the next month and subtract a day to get the last day of the current month\n",
    "    first_day_next_month = datetime(today.year, today.month + 1, 1) if today.month < 12 else datetime(today.year + 1, 1, 1)\n",
    "    last_day_current_month = first_day_next_month - timedelta(days=1)\n",
    "\n",
    "    # Find the last Thursday\n",
    "    days_to_last_thursday = (last_day_current_month.weekday() - 3) % 7\n",
    "    last_thursday = last_day_current_month - timedelta(days=days_to_last_thursday)\n",
    "\n",
    "    # Calculate the number of weekdays between today and the last Thursday\n",
    "    weekdays_count = 0\n",
    "    current_date = today\n",
    "\n",
    "    while current_date <= last_thursday:\n",
    "        if current_date.weekday() < 5:  # Monday=0, Sunday=6, so <5 means Mon-Fri\n",
    "            weekdays_count += 1\n",
    "        current_date += timedelta(days=1)\n",
    "\n",
    "    return weekdays_count"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "19773bd1",
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"## IMPORT OPTION CHAIN\"\"\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fd81b36a",
   "metadata": {
    "lines_to_next_cell": 1
   },
   "outputs": [],
   "source": [
    "import requests\n",
    "def import_option_chain_data(instrument_key,access_token_value):\n",
    "  url = 'https://api.upstox.com/v2/option/chain'\n",
    "  params = {\n",
    "      'instrument_key': instrument_key,\n",
    "      'expiry_date': '2024-08-29'\n",
    "  }\n",
    "  headers = {\n",
    "      'Accept': 'application/json',\n",
    "      'Authorization': f'Bearer {access_token_value}'\n",
    "  }\n",
    "\n",
    "  response = requests.get(url, params=params, headers=headers)\n",
    "  # Process the response data as needed\n",
    "  data=response.json()\n",
    "  df_call,df_put,df_general=format_option_chain_data_into_dataframe(data)\n",
    "  # print(response.json())\n",
    "  return df_call,df_put,df_general"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8462debd",
   "metadata": {
    "lines_to_next_cell": 1
   },
   "outputs": [],
   "source": [
    "def format_option_chain_data_into_dataframe(data):\n",
    "\n",
    "  # Extract general data\n",
    "  general_data = []\n",
    "  call_data = []\n",
    "  put_data = []\n",
    "\n",
    "  for item in data['data']:\n",
    "      general_info = {\n",
    "          'expiry': item.get('expiry'),\n",
    "          'strike_price': item.get('strike_price'),\n",
    "          'underlying_key': item.get('underlying_key'),\n",
    "          'underlying_spot_price': item.get('underlying_spot_price'),\n",
    "          'pcr': item.get('pcr')\n",
    "      }\n",
    "      general_data.append(general_info)\n",
    "\n",
    "      if 'call_options' in item:\n",
    "          call_option = item['call_options']\n",
    "          call_data.append({\n",
    "              'expiry': item['expiry'],\n",
    "              'strike_price': item['strike_price'],\n",
    "              'instrument_key': call_option['instrument_key'],\n",
    "              'ltp': call_option['market_data']['ltp'],\n",
    "              'volume': call_option['market_data']['volume'],\n",
    "              'oi': call_option['market_data']['oi'],\n",
    "              'close_price': call_option['market_data']['close_price'],\n",
    "              'bid_price': call_option['market_data']['bid_price'],\n",
    "              'bid_qty': call_option['market_data']['bid_qty'],\n",
    "              'ask_price': call_option['market_data']['ask_price'],\n",
    "              'ask_qty': call_option['market_data']['ask_qty'],\n",
    "              'prev_oi': call_option['market_data']['prev_oi'],\n",
    "              'vega': call_option['option_greeks']['vega'],\n",
    "              'theta': call_option['option_greeks']['theta'],\n",
    "              'gamma': call_option['option_greeks']['gamma'],\n",
    "              'delta': call_option['option_greeks']['delta'],\n",
    "              'iv': call_option['option_greeks']['iv']\n",
    "          })\n",
    "\n",
    "      if 'put_options' in item:\n",
    "          put_option = item['put_options']\n",
    "          put_data.append({\n",
    "              'expiry': item['expiry'],\n",
    "              'strike_price': item['strike_price'],\n",
    "              'instrument_key': put_option['instrument_key'],\n",
    "              'ltp': put_option['market_data']['ltp'],\n",
    "              'volume': put_option['market_data']['volume'],\n",
    "              'oi': put_option['market_data']['oi'],\n",
    "              'close_price': put_option['market_data']['close_price'],\n",
    "              'bid_price': put_option['market_data']['bid_price'],\n",
    "              'bid_qty': put_option['market_data']['bid_qty'],\n",
    "              'ask_price': put_option['market_data']['ask_price'],\n",
    "              'ask_qty': put_option['market_data']['ask_qty'],\n",
    "              'prev_oi': put_option['market_data']['prev_oi'],\n",
    "              'vega': put_option['option_greeks']['vega'],\n",
    "              'theta': put_option['option_greeks']['theta'],\n",
    "              'gamma': put_option['option_greeks']['gamma'],\n",
    "              'delta': put_option['option_greeks']['delta'],\n",
    "              'iv': put_option['option_greeks']['iv']\n",
    "          })\n",
    "\n",
    "  # Convert lists to DataFrames\n",
    "  df_general = pd.DataFrame(general_data)\n",
    "  df_call = pd.DataFrame(call_data)\n",
    "  df_put = pd.DataFrame(put_data)\n",
    "\n",
    "  # Display the DataFrames\n",
    "  # print(\"General Data DataFrame:\")\n",
    "  # print(df_general)\n",
    "\n",
    "  # print(\"\\nCall Options DataFrame:\")\n",
    "  # print(df_call)\n",
    "\n",
    "  # print(\"\\nPut Options DataFrame:\")\n",
    "  # print(df_put)\n",
    "  return df_call,df_put,df_general"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "eb7b6f26",
   "metadata": {
    "lines_to_next_cell": 1
   },
   "outputs": [],
   "source": [
    "def extrcting_only_ltp_and_strikes(df_call):\n",
    "\n",
    "  new_data_frame=df_call.iloc[:,[1,3]]\n",
    "  new_data_frame.drop(index=0,inplace=True)\n",
    "  new_data_frame.reset_index(drop=True,inplace=True)\n",
    "  my_strike_list=new_data_frame['strike_price'].tolist()\n",
    "  # print(new_data_frame)\n",
    "  return my_strike_list,new_data_frame"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bcda9da1",
   "metadata": {},
   "outputs": [],
   "source": [
    "def calculate_all_possible_spread_and_max_loss(instrument_key,access_token_value):\n",
    "  df_call,df_put,df_general=import_option_chain_data(instrument_key,access_token_value)\n",
    "  my_strike_list,new_data_frame=extrcting_only_ltp_and_strikes(df_call)\n",
    "  #calculation of all_max_loss_possible (it iis 2d array bw all ltp)\n",
    "  my_outer_list=[]\n",
    "  my_outer_list_spread=[]\n",
    "  for i in range(len(new_data_frame)):\n",
    "    my_list=[]\n",
    "    for j in range(len(new_data_frame)):\n",
    "      my_list.append(new_data_frame.iloc[i,1]-new_data_frame.iloc[j,1])\n",
    "\n",
    "    my_outer_list.append(my_list)\n",
    "\n",
    "   #calculate all_possible_spreads (it iis 2d array bw all striikes)\n",
    "\n",
    "  for i in range(len(new_data_frame)):\n",
    "    my_list_2=[]\n",
    "    for j in range(len(new_data_frame)):\n",
    "      my_list_2.append(new_data_frame.iloc[i,0]-new_data_frame.iloc[j,0])\n",
    "\n",
    "    my_outer_list_spread.append(my_list_2)\n",
    "\n",
    "  df_max_loss=pd.DataFrame(my_outer_list)\n",
    "  df_spread=pd.DataFrame(my_outer_list_spread)\n",
    "\n",
    "\n",
    "\n",
    "  #calculating risk reward ratio\n",
    "  df_risk_reward=(-df_spread-df_max_loss)/df_max_loss\n",
    "  # retaining only unique risk reward ratios\n",
    "\n",
    "\n",
    "  df_risk_reward=df_risk_reward.unstack().sort_values(ascending=False).dropna()\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "  #finding max_loss and max_profit corresponding to strikes in df_risk_reward\n",
    "  my_loss_listt=[]\n",
    "  my_max_profit_list=[]\n",
    "  for i in range(len(df_risk_reward)):\n",
    "    my_loss_listt.append(df_max_loss.iloc[df_risk_reward.index[i][1],df_risk_reward.index[i][0]])\n",
    "    my_max_profit_list.append(-df_spread.iloc[df_risk_reward.index[i][1],df_risk_reward.index[i][0]]-df_max_loss.iloc[df_risk_reward.index[i][1],df_risk_reward.index[i][0]])\n",
    "\n",
    "  df_risk_reward=pd.DataFrame(df_risk_reward)\n",
    "  df_risk_reward['loss']=my_loss_listt\n",
    "  df_risk_reward['profit']=my_max_profit_list\n",
    "\n",
    "  #retaining only positive losses and positive risk reward ratios\n",
    "  df_risk_reward=df_risk_reward[df_risk_reward['loss']>0 ]\n",
    "\n",
    "  df_risk_reward=df_risk_reward[df_risk_reward[0]>0 ]\n",
    "\n",
    "  # extracting only those strikes retaind corresponding to df_risk_reward\n",
    "  strike_1=[]\n",
    "  strike_2=[]\n",
    "\n",
    "  for i in range(len(df_risk_reward)):\n",
    "    strike_1.append(my_strike_list[df_risk_reward.index[i][0]])\n",
    "    strike_2.append(my_strike_list[df_risk_reward.index[i][1]])\n",
    "  df_risk_reward['strike_1']=strike_1\n",
    "  df_risk_reward['strike_2']=strike_2\n",
    "  df_risk_reward.columns=['reward','loss','profit','strike_1','strike_2']\n",
    "  df_risk_reward.reset_index(drop=True)\n",
    "  df_risk_reward.index\n",
    "\n",
    "  return df_risk_reward\n",
    "  # my_strike_list"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e5b2cafc",
   "metadata": {
    "lines_to_next_cell": 1
   },
   "outputs": [],
   "source": [
    "\"\"\"## CALCULATE MEAN AND STD\"\"\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c726f4eb",
   "metadata": {},
   "outputs": [],
   "source": [
    "def cal_ploting_mean_std_returns(historical_stock_data):\n",
    "  req_data=pd.DataFrame(historical_stock_data)\n",
    "  req_data.reset_index(inplace=True)\n",
    "\n",
    "\n",
    "  per_change=[None]\n",
    "\n",
    "\n",
    "  for i in range(1,len(req_data)):\n",
    "    change=((req_data.iloc[i,1]-req_data.iloc[i-1,1])/req_data.iloc[i-1,1])*100\n",
    "    per_change.append(change)\n",
    "\n",
    "\n",
    "  req_data['%change']=per_change\n",
    "\n",
    "  req_data=req_data.drop(index=0)\n",
    "\n",
    "  req_data\n",
    "  mean=req_data['%change'].mean()\n",
    "  std=req_data['%change'].std()\n",
    "  # print(f'mean % chaneg is {mean}, and std dev is{std}')\n",
    "\n",
    "  # plt.figure(figsize=(10,5))\n",
    "  # sns.histplot(req_data['%change'],kde=True)\n",
    "  # plt.axvline(mean,color='r',linestyle='--')\n",
    "  # plt.axvline(mean+std,color='g',linestyle='--')\n",
    "  # plt.axvline(mean-std,color='g',linestyle='--')\n",
    "  # plt.show()\n",
    "  return mean,std,req_data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "66ae99c2",
   "metadata": {
    "lines_to_next_cell": 1
   },
   "outputs": [],
   "source": [
    "import math\n",
    "def linear_range(current_price,historical_stock_data):\n",
    "\n",
    "\n",
    "  # data=yf.download(tickers=f'{symbol}.NS',period='max',interval='1d')\n",
    "  # historical_stock_data=data['Adj Close']\n",
    "  n=weekdays_until_last_thursday()\n",
    "  mean,std,req_data=cal_ploting_mean_std_returns(historical_stock_data)\n",
    "\n",
    "\n",
    "  pos_change_in_next_ndays=n*mean+std*math.sqrt(n)\n",
    "  neg_change_in_next_ndays=n*mean-std*math.sqrt(n)\n",
    "\n",
    "  upper_range=current_price*(1+pos_change_in_next_ndays/100)\n",
    "  lower_range=current_price*(1+neg_change_in_next_ndays/100)\n",
    "\n",
    "  return pos_change_in_next_ndays,neg_change_in_next_ndays,lower_range,upper_range"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5564dfff",
   "metadata": {
    "lines_to_next_cell": 1
   },
   "outputs": [],
   "source": [
    "def exponential_range(current_price,historical_stock_data):\n",
    "  # data=yf.download(tickers=f'{symbol}.NS',period='max',interval='1d')\n",
    "  # historical_stock_data=data['Adj Close']\n",
    "  mean,std,req_data=cal_ploting_mean_std_returns(historical_stock_data)\n",
    "  n=weekdays_until_last_thursday()\n",
    "#linear_range_calculation\n",
    "  pos_change_in_next_ndays=(n*mean+std*math.sqrt(n))/100\n",
    "  neg_change_in_next_ndays=(n*mean-std*math.sqrt(n))/100\n",
    "\n",
    "  upper_range=current_price*math.exp(pos_change_in_next_ndays)\n",
    "  lower_range=current_price*math.exp(neg_change_in_next_ndays)\n",
    "\n",
    "  return math.exp(pos_change_in_next_ndays)-1,math.exp(neg_change_in_next_ndays)-1,lower_range,upper_range"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "aeb73d95",
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"## VOLATILITY_CONE\"\"\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a85d64ab",
   "metadata": {
    "lines_to_next_cell": 1
   },
   "outputs": [],
   "source": [
    "from datetime import datetime, timedelta"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1d6c4cea",
   "metadata": {
    "lines_to_next_cell": 1
   },
   "outputs": [],
   "source": [
    "def is_last_thursday(date):\n",
    "    # Ensure the input date is a datetime object\n",
    "    if not isinstance(date, datetime):\n",
    "        date = datetime.strptime(date, '%Y-%m-%d')\n",
    "\n",
    "    # Get the year and month of the given date\n",
    "    year = date.year\n",
    "    month = date.month\n",
    "\n",
    "    # Find the last day of the month\n",
    "    if month == 12:\n",
    "        last_day_of_month = datetime(year + 1, 1, 1) - timedelta(days=1)\n",
    "    else:\n",
    "        last_day_of_month = datetime(year, month + 1, 1) - timedelta(days=1)\n",
    "\n",
    "    # Calculate the last Thursday of the month\n",
    "    last_thursday_of_month = last_day_of_month - timedelta(days=(last_day_of_month.weekday() - 3) % 7)\n",
    "\n",
    "    # Check if the given date is the last Thursday\n",
    "    return date.date() == last_thursday_of_month.date()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "69babc93",
   "metadata": {},
   "source": [
    "Example usage\n",
    "date_str = '2024-08-29'  # Example date (YYYY-MM-DD)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b1c67a5a",
   "metadata": {},
   "source": [
    "date = datetime.strptime(date_str, '%Y-%m-%d')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d19a1d98",
   "metadata": {},
   "outputs": [],
   "source": [
    "def plotting_volatility_cone(historical_stock_data):\n",
    "\n",
    "\n",
    "  mean,std,req_data=cal_ploting_mean_std_returns(historical_stock_data)\n",
    "\n",
    "  no_days_before_expiry=weekdays_until_last_thursday()\n",
    "  req_data['vol_next_18_days']=np.nan\n",
    "  for i in range(0,len(req_data)-no_days_before_expiry+1):\n",
    "    req_data.iloc[i,3]=(np.std(req_data.iloc[i:i+no_days_before_expiry,2]))\n",
    "\n",
    "\n",
    "  volatility_cone=[]\n",
    "\n",
    "  for i in range(len(req_data)):\n",
    "    date=req_data.iloc[i,0]\n",
    "    if is_last_thursday(date):\n",
    "      volatility_cone.append(req_data.iloc[i-no_days_before_expiry+1,3])\n",
    "      # print(req_data.iloc[i-17,0])\n",
    "\n",
    "  volatility_cone=pd.DataFrame(volatility_cone)\n",
    "  volatility_cone.columns=['past_volatility']\n",
    "  n=math.sqrt(252)\n",
    "  volatility_cone=volatility_cone*n\n",
    "  # volatility_cone\n",
    "  # plt.plot(figsize=(10,5))\n",
    "  # sns.histplot(volatility_cone['past_volatility'],kde=True)\n",
    "  # plt.show()\n",
    "  mean_vol = volatility_cone['past_volatility'].mean()\n",
    "  std_vol = volatility_cone['past_volatility'].std()\n",
    "\n",
    "  list_range_past_volatility = [\n",
    "      volatility_cone['past_volatility'].min(),\n",
    "      mean_vol - 2 * std_vol,\n",
    "      mean_vol - std_vol,\n",
    "      mean_vol,\n",
    "      mean_vol + std_vol,\n",
    "      mean_vol + 2 * std_vol,\n",
    "      volatility_cone['past_volatility'].max()\n",
    "  ]\n",
    "  return list_range_past_volatility\n",
    "  # print(f\"mean annualised volatility of {no_days_before_expiry} days before expiry  is {volatility_cone['past_volatility'].mean()}and std is {volatility_cone['past_volatility'].std()}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8507a28b",
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"## MONTE CARLO\"\"\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b8e3dcca",
   "metadata": {
    "lines_to_next_cell": 1
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "def monte_carlo_simulation(current_price,historical_stock_data,num_simulations):\n",
    "\n",
    "  # Define inputs\n",
    "    mean,std,req_data=cal_ploting_mean_std_returns(historical_stock_data)\n",
    "    mean_return = mean\n",
    "    volatility = std\n",
    "    days = weekdays_until_last_thursday()\n",
    "       # Adjust this to a higher number if needed\n",
    "\n",
    "    # Initialize array to store the price paths\n",
    "    price_paths = np.zeros((days + 1, num_simulations))\n",
    "\n",
    "    # Set the initial price\n",
    "    price_paths[0] = current_price\n",
    "\n",
    "    # Run simulations\n",
    "    for i in range(num_simulations):\n",
    "        for t in range(1, days + 1):\n",
    "            daily_return = np.random.normal(mean_return, volatility)\n",
    "            price_paths[t, i] = price_paths[t-1, i] * (1 + daily_return/100)\n",
    "\n",
    "    # Plotting the simulation paths\n",
    "    # plt.figure(figsize=(10, 6))\n",
    "    # plt.plot(price_paths)\n",
    "    # plt.title('Monte Carlo Simulation of Stock Price Over 5 Days')\n",
    "    # plt.xlabel('Days')\n",
    "    # plt.ylabel('Stock Price')\n",
    "\n",
    "    # plt.grid(True)\n",
    "    # plt.show()\n",
    "\n",
    "    # Calculate percentiles for the final prices\n",
    "    final_prices = price_paths[-1]\n",
    "    lower_bound = np.percentile(final_prices, 5)\n",
    "    upper_bound = np.percentile(final_prices, 95)\n",
    "\n",
    "    # print(f\"5th Percentile Price: ${lower_bound:.2f}\",\"for \",current_price)\n",
    "    # print(f\"95th Percentile Price: ${upper_bound:.2f}\",\"for\",current_price)\n",
    "    # print(\"\\n\")\n",
    "    return lower_bound,upper_bound"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c298ca56",
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"## GEOMETRRIC BROWNIAN SIMULATION\"\"\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b0aa2831",
   "metadata": {
    "lines_to_next_cell": 1
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "def geometric_brownian_motion_simulation(current_price,historical_stock_data,no_of_simulation_to_run):\n",
    "# Define inputs\n",
    "    mean,std,req_data=cal_ploting_mean_std_returns(historical_stock_data)\n",
    "    current_price = current_price\n",
    "    daily_mean_return = mean/100  # Daily mean return\n",
    "    daily_volatility = std/100  # Daily volatility\n",
    "    days = weekdays_until_last_thursday()\n",
    "    num_simulations = no_of_simulation_to_run\n",
    "    dt = 1  # time step (1 day)\n",
    "\n",
    "    # Initialize array to store price paths\n",
    "    price_paths = np.zeros((days + 1, num_simulations))\n",
    "    price_paths[0] = current_price\n",
    "\n",
    "    # Run simulations\n",
    "    for i in range(num_simulations):\n",
    "        for t in range(1, days + 1):\n",
    "            # Simulate random component\n",
    "            rand = np.random.normal(0, 1)\n",
    "            # Calculate the price using GBM formula\n",
    "            price_paths[t, i] = price_paths[t-1, i] * np.exp((daily_mean_return - 0.5 * daily_volatility**2) * dt + daily_volatility * np.sqrt(dt) * rand)\n",
    "\n",
    "    # Plotting the simulation paths\n",
    "    # plt.figure(figsize=(10, 6))\n",
    "    # plt.plot(price_paths)\n",
    "    # plt.title('Geometric Brownian Motion Simulation of Stock Price Over 5 Days')\n",
    "    # plt.xlabel('Days')\n",
    "    # plt.ylabel('Stock Price')\n",
    "    # plt.grid(True)\n",
    "    # plt.show()\n",
    "\n",
    "    # Calculate percentiles for the final prices\n",
    "    final_prices = price_paths[-1]\n",
    "    lower_bound = np.percentile(final_prices, 5)\n",
    "    upper_bound = np.percentile(final_prices, 95)\n",
    "\n",
    "    # print(f\"5th Percentile Price: ${lower_bound:.2f}\",\"for\",current_price)\n",
    "    # print(f\"95th Percentile Price: ${upper_bound:.2f}\",\"for\",current_price)\n",
    "    print(\"\\n\")\n",
    "    return lower_bound,upper_bound"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "129d2123",
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"## SELCTING STOCKS WITH UNUSUAL VOLATILTY COMAPRED TO THEIR PAST\"\"\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "283ed6c0",
   "metadata": {
    "lines_to_next_cell": 1
   },
   "outputs": [],
   "source": [
    "import yfinance as yf\n",
    "def volatility_cone_for_all_stocks(df_only_options_stock):\n",
    "  no_of_days_before_expiry=weekdays_until_last_thursday()\n",
    "  df_past_volatilty_range=pd.DataFrame(columns=['SYMBOL','MIN','-2STD','-1STD','MEAN','+1STD','+2STD','MAX'])\n",
    "  for index,stocks in enumerate(df_only_options_stock['Symbol']):\n",
    "    if stocks=='L&TFH':\n",
    "      data=yf.download(tickers='LTF.NS',period='max',interval='1d')\n",
    "    elif stocks=='MCDOWELL-N':\n",
    "      data=yf.download(tickers='UBL.BO',period='max',interval='1d')\n",
    "    else:\n",
    "      data=yf.download(tickers=f'{stocks}.NS',period='max',interval='1d')\n",
    "\n",
    "    historical_stock_data=data['Adj Close']\n",
    "    # mean,std,req_data=cal_ploting_mean_std_returns(historical_stock_data)\n",
    "    list_range_past_volatility=plotting_volatility_cone(historical_stock_data)\n",
    "    list_range_past_volatility.insert(0,stocks);\n",
    "    df_past_volatilty_range.loc[len(df_past_volatilty_range)]=list_range_past_volatility\n",
    "  return df_past_volatilty_range"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c4f88207",
   "metadata": {},
   "outputs": [],
   "source": [
    "def comparing_atm_iv_with_past_volatility_range(df_only_options_stock,access_token_value):\n",
    "  list_atm_iv=[]\n",
    "  rejection_list=[]\n",
    "  df=pd.read_csv(\"https://drive.google.com/uc?export=download&id=1Dyt6laIWQNO4p6FHyw335QG8rKLyeXP1\")\n",
    "  for symbol in df_only_options_stock['Symbol']:\n",
    "\n",
    "      instrument_key=df[df['Symbol']==symbol]['instrument_key'].values[0]\n",
    "      df_call,df_put,df_general=import_option_chain_data(instrument_key,access_token_value)\n",
    "      if df_call.empty:\n",
    "        rejection_list.append(symbol)\n",
    "        continue\n",
    "      spot_price=df_general['underlying_spot_price'].values[0]\n",
    "      #find atm strike price\n",
    "      df_call['diff']=abs(df_call['strike_price']-spot_price)\n",
    "      row_with_min__diif=df_call.loc[df_call['diff'].idxmin()]\n",
    "      list_atm_iv.append([symbol,row_with_min__diif['strike_price'],row_with_min__diif['iv']])\n",
    "      df_atm_iv=pd.DataFrame(list_atm_iv,columns=['SYMBOL','STRIKE_PRICE','ATM_IV'])\n",
    "  df_past_volatility_range=volatility_cone_for_all_stocks(df_only_options_stock)\n",
    "  df_past_volatility_range=df_past_volatility_range.merge(df_atm_iv,on='SYMBOL')\n",
    "  return df_past_volatility_range"
   ]
  }
 ],
 "metadata": {
  "jupytext": {
   "cell_metadata_filter": "-all",
   "encoding": "# -*- coding: utf-8 -*-",
   "main_language": "python",
   "notebook_metadata_filter": "-all"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
